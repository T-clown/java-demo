https://mp.weixin.qq.com/s/YfcRjHhbStm2T7Yheif7ug

https://mp.weixin.qq.com/s/RaD3SqZ9ytYTwCgz3HpEsg

1.程序计数器
    为了线程切换后能恢复到正确的执行位置，就要求每个线程都需要有个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。所以程序计数器是线程私有的。
    另外，程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
    
2.Java虚拟机栈
    线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时，都会创建一个栈帧，用于存储局部变量表（基本数据类型，对象的引用和returnAddress类型）、操作数栈、动态链接、方法出口等信息。
    局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
    每个方法被调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中从入栈到出栈的过程。对于Java虚拟机栈，有两种以尝情况：
    1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。
    2. 如果虚拟机栈在动态扩展时，无法申请到足够的内存，就会抛出OutOfMemoryError异常。
    
3. 本地方法栈
    本地方法栈和虚拟机栈所发挥的作用非常相似，它们之间的区别主要是：虚拟机栈是为虚拟机执行的Java方法（即字节码）服务的，而本地方法栈则为虚拟机使用到的Native方法服务。
    与虚拟机栈类似，本地方法栈也会抛出StackOverFlowError和OutOfMemoryError异常。
    
4. Java堆
    Java堆是Java虚拟机所管理的内存中最大的一块。Java堆在主内存中，是被所有线程共享的一块内存区域，其随着JVM的创建而创建，堆内存的唯一目的是存放对象实例和数组。同时Java堆也是GC管理的主要区域。
    Java堆在物理上不需要连续的内存，只要逻辑上连续即可。如果堆中没有内存完成实例分配，并且也无法再扩展时，将会抛出OutOfMemoryError异常。
    
5. 方法区
    方法区是所有线程共享的一块内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也有一个别名叫Non-heap（非堆），用来与Java堆区分。对于HotSpot虚拟机来说，方法区又习惯成为“永久代（Permancent Generation）”，但这只是对于HotSpot虚拟机来说的，其他虚拟机的实现上并没有这个概念。相对而言，垃圾收集行为在这个区域比较少出现，但也并非不会来收集，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载上。
    根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。
    
6. 运行时常量池
    运行时常量池属于方法区。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量表，用于存放编译期生成的各种字面常量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放（JDK1.7开始，常量池已经被移到了堆内存中了）。
    也就是说，这部分内容，在编译时只是放入到了常量池信息中，到了加载时，才会放到运行时常量池中去。运行时常量池县归于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的是String类的intern()方法。
    当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常，常量池属于方法区，同样可能抛出OutOfMemoryError异常。

https://mp.weixin.qq.com/s/Km9rpES2pc6K_I5lyiYT2w
1、-Xmx512m：设置Java虚拟机的堆的最大可用内存大小，单位：兆(m)，整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。
            持久代一般固定大小为64m。堆的不同分布情况，对系统会产生一定的影响。尽可能将对象预留在新生代，减少老年代GC的次数（通常老年回收起来比较慢）。
            实际工作中，通常将堆的初始值和最大值设置相等，这样可以减少程序运行时进行的垃圾回收次数和空间扩展，从而提高程序性能。

2、-Xms512m：设置Java虚拟机的堆的初始值内存大小，单位：兆(m)，此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。

3、-Xmn170m：设置年轻代内存大小，单位：兆(m)，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。一般在增大年轻代内存后，也会将会减小年老代大小。

4、-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，以前每个线程栈大小为256K。更具应用的线程所需内存大小进行调整。
            在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。

5、-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 。

6、-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。

7、-XX:MaxPermSize=16m：设置持久代大小为16m，上面也说了，持久代一般固定的内存大小为64m。

8、-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。
    如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。
    如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。
    
Java虚拟机的垃圾回收策略一般分为：串行收集器、并行收集器和并发收集器
串行收集器：
1、-XX:+UseSerialGC：代表垃圾回收策略为串行收集器，即在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，主要在JDK1.5之前的垃圾回收方式。

并行收集器：
1、-XX:+UseParallelGC：代表垃圾回收策略为并行收集器(吞吐量优先)，即在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。
    此配置仅对年轻代有效。该配置只能让年轻代使用并发收集，而年老代仍旧使用串行收集

2、-XX:ParallelGCThreads=4：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。

3、-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 。

4、-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。

5、-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。

并发收集器：
1、-XX:+UseConcMarkSweepGC:代表垃圾回收策略为并发收集器。
